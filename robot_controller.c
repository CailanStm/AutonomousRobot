#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftLightSensor, sensorReflection)
#pragma config(Sensor, in2,    rightLightSensor, sensorReflection)
#pragma config(Sensor, dgtl1,  sonarSensorIn,  sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  backLeft,       sensorTouch)
#pragma config(Sensor, dgtl4,  backRight,      sensorTouch)
#pragma config(Sensor, dgtl9,  LEDYellow,      sensorDigitalOut)
#pragma config(Sensor, dgtl10, LEDRed,         sensorDigitalOut)
#pragma config(Sensor, dgtl11, frontRight,     sensorTouch)
#pragma config(Sensor, dgtl12, frontLeft,      sensorTouch)
#pragma config(Sensor, I2C_1,  encoderOne,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  encoderTwo,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           motorRight,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motorLeft,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void monitorLightValue();
void driveToBeacon();
int scanNoPID(int angle, int mode);
void turnToStrongestIR(int strongestVal);
void turnToStrongestSonar(int strongestVal);
void locateObject();
void monitorButtons();
void monitorRears();
void pickUp();
void dropOff();
void backUp(int numClicks);
void driveUntilDistance(int stopDistance);
void scanWall();
void driveStraight(int leftPower);
void driveUntilButtons();
void flashLights();
void turnFast(int numClicks);

bool frontRightPushed;
bool frontLeftPushed;
bool backRightPushed;
bool backLeftPushed;
int rightLevelIR;
int leftLevelIR;
int maxMinDifference = 100;
int fullTurn = 1900;
int turnAngle = 400;
int closeDistanceCM = 20;
int scanSonarValue;
int state;
int clicksDriven = 0;
float sonarPercentError = 0.15;
float rightMotorError = 1.1;

/* This uses the two infrared sensors to monitor for IR light flashing at 10 Hz.
 * The method takes 101 milliseconds to run. During this time, it takes 4 readings from each of the IR sensors.
 * For each sensor, if the difference between the largest reading and smallest reading is quite large (larger than maxMinDifference),
 * then we know that it is detecting the IR beacon; otherwise, it is just detecting background IR.
 *
 * If it is detecting a source, the corresponding global variable (leftLevelIR or rightLevelIR) is set to the minimum
 * value read during this time (which will be the actual reading from the IR source).
 * Otherwise, the corresponding global variable is set to 10000, to represent background IR light.
 */
void monitorLightValue() {
	clearTimer(T2);
	int rightMinValue = 4096;
	int leftMinValue = 4096;
	int rightMaxValue = 0;
	int leftMaxValue = 0;
	int tempRightLevelIR, tempLeftLevelIR;

	while (time1(T2) < 101) {
		if (time1(T2) % 25 == 0) {
			tempRightLevelIR = SensorValue[rightLightSensor];
			tempLeftLevelIR = SensorValue[leftLightSensor];

			if (tempRightLevelIR < rightMinValue ) {
				rightMinValue = tempRightLevelIR;
			} else if ( tempRightLevelIR > rightMaxValue ) {
				rightMaxValue = tempRightLevelIR;
			}

			if (tempLeftLevelIR < leftMinValue ) {
				leftMinValue = tempLeftLevelIR;
			} else if ( tempLeftLevelIR > leftMaxValue ) {
				leftMaxValue = tempLeftLevelIR;
			}
		}
	}

	if (rightMaxValue - rightMinValue > maxMinDifference) {
		rightLevelIR = rightMinValue;
	} else {
		rightLevelIR = 10000;
	}
	if (leftMaxValue - leftMinValue > maxMinDifference) {
		leftLevelIR = leftMinValue;
	} else {
		leftLevelIR = 10000;
	}
}

/*
 * Drives to the beacon, while making real time corrections based on the two phototransisor readings.
 * Has three modes based on the current sonar reading (which would be the distance from the beacon), and
 * corrects differently based on these readings.
 *
 * At a sonar value greater than 25, if only one phototransistor has a reading, turn hard in the other direction slowing one
 * motor down and speeding the other up. If they both have a reading but one is stronger than the other, do the same but less
 * drastically. If they are within the acceptable difference of each other, drive straight.
 *
 * Similar logic for when the sonar value is between 20 and 25. Once it is within 20, drive straight, and once it is
 * within 14, stop.
 */
void driveToBeacon() {
	resetMotorEncoder(motorRight);
	resetMotorEncoder(motorLeft);

	motor[motorLeft] = 60;
	motor[motorRight] = 60;
	int acceptableDifference = 20;
	clearTimer(T1);

	while (SensorValue[sonarSensorIn] > 25 && SensorValue[sonarSensorIn] != -1) {
		monitorLightValue();
		if (!(rightLevelIR == 10000 && leftLevelIR == 10000) ) {
			if (abs(rightLevelIR - leftLevelIR) > acceptableDifference && rightLevelIR >= leftLevelIR) {
				if (rightLevelIR > 4500) {
					motor[motorRight] = 80*rightMotorError;
					motor[motorLeft] = 20;
				} else {
					motor[motorRight] = 60*rightMotorError;
					motor[motorLeft] = 40;
				}
			} else if (abs(rightLevelIR - leftLevelIR) > acceptableDifference && rightLevelIR < leftLevelIR) {
				if (leftLevelIR > 4500) {
					motor[motorRight] = 20*rightMotorError;
					motor[motorLeft] = 80;
				} else {
					motor[motorRight] = 40*rightMotorError;
					motor[motorLeft] = 60;
				}
			} else if (abs(rightLevelIR - leftLevelIR) <= acceptableDifference){
				driveStraight(60);
			}
		} else {
			state = 1;
			return;
		}
	}

	while (SensorValue[sonarSensorIn] > 19) {
		monitorLightValue();
		if (!(rightLevelIR == 10000 && leftLevelIR == 10000) ) {
			if (rightLevelIR - acceptableDifference > leftLevelIR) {
				motor[motorRight] = 45*rightMotorError;
				motor[motorLeft] = 35;
			} else if (rightLevelIR - acceptableDifference < leftLevelIR) {
				motor[motorRight] = 35*rightMotorError;
				motor[motorLeft] = 45;
			} else if (abs(rightLevelIR - leftLevelIR) < acceptableDifference){
				driveStraight(60);
			}
		} else {
			driveStraight(60);
		}
	}

	while (SensorValue[sonarSensorIn] > 14) {
		driveStraight(60);
	}

	motor[motorLeft] = 0;
	motor[motorRight] = 0;

	state = 2;
}

/*
 * Spins while monitoring for either IR readings or sonar readings, or neither
 * If mode = 0, monitors neither. If mode = 1, monitors for the strongest sonar value, and returns this value.
 * If mode = 2, monitors for the strongest IR signal (based on the sum of the two phototransistor readings),
 * and returns this value. Also sets the global variable "scanSonarValue" to be the recorded
 * sonar value at the position of strongest IR reading.
 *
 * The parameter "angle" specifies how many clicks the robot should spin while scanning.
 */
int scanNoPID(int angle, int mode) {
	resetMotorEncoder(motorLeft);
	resetMotorEncoder(motorRight);

	int k = (angle)/(abs(angle));

	rightLevelIR = 10000;
	leftLevelIR = 10000;
	int minSum = 20000;

	int rotation = 0;
	scanSonarValue = 1000;

	bool detected = false;
	SensorValue[LEDYellow] = 0;
	SensorValue[LEDRed] = 0;

	int minDistance = 1000;
	int currDistance;

	if (mode == 1) {
		motor[motorLeft] = k * (60);
		motor[motorRight] = k * -1 * (60);
	} else {
		motor[motorLeft] = k * (80);
		motor[motorRight] = k * -1 * (80);
	}

	while (abs(rotation) < abs(angle)) {
		rotation = (k == 1) ? getMotorEncoder(motorRight) : getMotorEncoder(motorLeft); //we found that using the motor 2 encoder for clockwise rotation and the motor 1 encoder for counter clockwise rotation gave more accurate turning

		if (mode == 1) {
			currDistance = SensorValue[sonarSensorIn];
			if (currDistance < minDistance && currDistance != -1) {
				minDistance = currDistance;
			}
		} else if (mode >= 2){
			monitorLightValue();
			if (rightLevelIR + leftLevelIR < minSum && rightLevelIR < 10000 && leftLevelIR < 10000) {
				detected = true;
				SensorValue[LEDYellow] = 1;
				minSum = rightLevelIR + leftLevelIR;
				if (mode == 2) {
					scanSonarValue = SensorValue[sonarSensorIn];
				}
			}
		}
	}

	motor[motorLeft] = 0;
	motor[motorRight] = 0;

	if (mode == 1) {
		return minDistance;
	} else {
		return minSum;
	}
}
/*
 * Turns the robot until the sum of the values of the phototransistors is within a threshold of strongestVal
 * The threshold is increased if the initial scan (the one that returned strongestVal) showed that we were quite close to the beacon
 */
void turnToStrongestIR(int strongestVal) {
	bool close = (scanSonarValue < 60 && scanSonarValue != -1);

	if (close) {
		SensorValue[LEDRed] = 1;
	}

	resetMotorEncoder(motorRight);

	motor[motorLeft] = -50;
	motor[motorRight] = 50;
	while (true) {
		monitorLightValue();
		if (!close) {
			int average = ((rightLevelIR + leftLevelIR) / 2);
			if ( (rightLevelIR + leftLevelIR <= strongestVal * 1.2) && (abs(rightLevelIR - leftLevelIR) < (average * 0.1))) {
				break;
			}
		} else if (scanSonarValue > 40) {
			if ( rightLevelIR + leftLevelIR <= strongestVal * 1.3 ) {
				break;
			}
		} else {
			if ( ( rightLevelIR + leftLevelIR <= strongestVal * 1.4 ) ) {
				break;
			}
		}
	}
	motor[motorLeft] = 0;
	motor[motorRight] = 0;

	if (close) {
		backUp(380);
	}
}

/*
 * Turns the robot until the value of the sonar sensor equals strongestVal, with a threshold of 20%
 */
void turnToStrongestSonar(int strongestVal) {
	motor[motorLeft] = 50;
	motor[motorRight] = -50;
	resetMotorEncoder(motorRight);

	while (true) {
		if (SensorValue[sonarSensorIn] <= strongestVal + (strongestVal * 0.2) && SensorValue[sonarSensorIn] != -1) {
			break;
		}
		if (state == 5) {
			if (abs(getMotorEncoder(motorRight)) > 2300) {
				sonarPercentError += 0.05; //if the first scan doesn't work, increase the scan's threshold
				return; //will then start the scan again, since state is still 5
			}
		}
	}
	motor[motorLeft] = 0;
	motor[motorRight] = 0;

	state = 6;
}

/*
 * Scans while looking for the strongest sonar value, and then turns until it sees that value again (within a threshold)
 */
void locateObject() {
	int smallestVal = scanNoPID(fullTurn, 2);
	if (scanSonarValue < 60) {
		SensorValue[LEDRed] = 1;
	}
	turnToStrongestIR(smallestVal);

	state = 1;
}

// Turns on the bools frontLeftPushed and frontRightPushed if their respective limit switches have been pressed
void monitorButtons() {
	if (SensorValue(frontLeft) == 1 && !frontLeftPushed) {
		frontLeftPushed = true;
	}
	if (SensorValue(frontRight) == 1 && !frontRightPushed) {
		frontRightPushed = true;
	}
}

/*
 * Turns on the bools backLeftPushed and backRightPushed if their respective bump sensors have been pressed
 */
void monitorRears() {
	if (SensorValue(backLeft) == 1 && !backLeftPushed) {
		backLeftPushed = true;
	}
	if (SensorValue(backRight) == 1 && !backRightPushed) {
		backRightPushed = true;
	}
}

/*
 * Lowers and then raises the magnet (to pick up the object)
 */
void pickUp() {

	clearTimer(T1);
	motor[armMotor] = -50;
	while (time1[T1] < 1600) {
		continue;
	}
	motor[armMotor] = 0;

	clearTimer(T1);
	motor[armMotor] = 50;
	while (time1[T1] < 2550) {
		continue;
	}
	motor[armMotor] = 0;

	state = 3;
}

/*
 * Lowers the magnet until it is completely unravelled (to drop it over the wall)
 */
void dropOff() {
	clearTimer(T1);

	motor[armMotor] = -200;

	while (time1[T1] < 5300) {
		continue;
	}

	motor[armMotor] = 0;

	state = 7;
}

/*
 * Backs the robot up numClicks, or until a rear bumper is pressed
 */
void backUp(int numClicks) {
	resetMotorEncoder(motorRight);
	backLeftPushed = false;
	backRightPushed = false;

	motor[motorLeft] = -60;
	motor[motorRight] = -60;

	while (getMotorEncoder(motorRight) > -1 * numClicks) {
		monitorRears();
		if (backLeftPushed || backRightPushed) {
			break;
		}
	}

	motor[motorLeft] = 0;
	motor[motorRight] = 0;
}

/*
 * Drives straight until the robot is within a certain distance from the wall, or a button is pushed
 */
void driveUntilDistance(int stopDistance) {
	frontLeftPushed = false;
	frontRightPushed = false;

	int sonarVal = SensorValue[sonarSensorIn];

	while ((sonarVal > stopDistance) && (sonarVal != -1) && !frontLeftPushed && !frontRightPushed) {
		monitorButtons();
		sonarVal = SensorValue[sonarSensorIn];

		driveStraight(80);
	}

	motor[motorRight] = 0;
	motor[motorLeft] = 0;

	state = 5;
}

/*
 * Scans and records the closest sonar value, and then turns until it finds that value again (within a threshold)
 */
void scanWall() {
	scanNoPID(turnAngle, 0);
	wait1Msec(250);
	int minDistance = scanNoPID(-2 * turnAngle, 1);
	wait1Msec(250);
	turnToStrongestSonar(minDistance);
}

/*
 * Makes the robot drive physically straight, correcting for motor differences.
 * leftPower is the power that the left motor will be set to.
 */
void driveStraight(int leftPower) {
	motor[motorLeft] = leftPower;
	motor[motorRight] = (leftPower * rightMotorError);
}

/*
 * Drives straight until a button is pushed and the sensor value is smaller than 10
 * This is to ensure it reaches the wall
 */
void driveUntilButtons() {
	motor[motorLeft] = 60;
	motor[motorRight] = 60;
	frontLeftPushed = false;
	frontRightPushed = false;

	while (true) {
		monitorButtons();
		if ((frontLeftPushed || frontRightPushed) && SensorValue[sonarSensorIn] < 10) {
			break;
		}
	}

	motor[motorLeft] = 0;
	motor[motorRight] = 0;
}

/*
 * Flashes the LEDs to signal job completion
 */
void flashLights() {
	clearTimer(T1);
	while (time1[T1] < 3000) {
		SensorValue[LEDRed] = 1;
		SensorValue[LEDYellow] = 1;
		wait1Msec(100);
		SensorValue[LEDRed] = 0;
		SensorValue[LEDYellow] = 0;
		wait1Msec(100);
	}
}

/*
 * Turns "numClicks" clockwise at the top motor speed
 */
void turnFast(int numClicks) {
	resetMotorEncoder(motorRight);
	motor[motorLeft] = 180;
	motor[motorRight] = -180;

	while (abs(getMotorEncoder(motorRight)) < numClicks) {
		continue;
	}


	motor[motorLeft] = 0;
	motor[motorRight] = 0;
}

task main()
{
	state = 0;
	SensorValue[LEDRed] = 0;
	SensorValue[LEDYellow] = 0;
	wait1Msec(200);

	while (true) {
		switch(state) {
			case (0):
				locateObject();
				break;
			case (1):
				driveToBeacon();
				break;
			case (2):
				wait1Msec(500);
				pickUp();
				break;
			case (3):
				wait1Msec(100);
				backUp(300);
				turnFast(900);
				state = 4;
				break;
			case (4):
				driveUntilDistance(closeDistanceCM);
				backUp(200);
				break;
			case (5):
				scanWall();
				break;
			case (6):
				driveUntilButtons();
				dropOff();
				break;
			case (7):
				flashLights();
				break;
		}
	}
}
